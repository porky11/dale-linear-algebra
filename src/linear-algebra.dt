(import util)
(import array)
(import concepts)

(using-namespace std.concepts
(using-namespace std.macros

(def-concept Matrix (refines Type) (T) true) ;;will have to define 2d size function and value type and 2d accessor

(def-type-macro3 Matrix)

;;TODO use a generic multidimensional Array type for representing Matrices
(def-concept-macro Matrix extern ((T Type) (N Value) (M Value))
  (let ((Mat \ (qq Matrix (uq T) (uq N) (uq M))))
    (qq do
      (def (uq Mat)
        (struct extern ((elements (array-of (uq N) (array-of (uq M) (uq T)))))))
      (def frobenius-norm (fn extern (retval (uq T)) ((a (ref (uq Mat))))
        (setf retval (cast 0 (uq T)))
        (for (i int 0) (< i (uq M)) (incv i)
          (for (j int 0) (< j (uq N)) (incv j)
            (incf retval (@$' (@:@ a elements) i j))))))
      (def transpose (fn (retval (uq Mat)) ((a (ref (uq Mat))))
        (for (i int 0) (< i (uq M)) (incv i)
          (for (j int 0) (< j (uq N)) (incv j)
            (setv (@$' (@:@ retval elements) j i)) (@$' (@:@ a elements) i j)))))
      (def value-type (macro extern ((arrp (p (Array (uq T) (uq N))))) (q (uq T))))
      (def size (fn extern size ((arrp (ref (const (Matrix (uq T) (uq N) (uq M))))) (a int))
        (if (= a 0) (uq N)
                    (uq M)))))))

(def-concept-macro + extern ((Mat Matrix))
  (def N (var auto \ (qq size (@ retval) 0)))
  (def M (var auto \ (qq size (@ retval) 1)))
  (qq def + (fn extern (retval (uq Mat)) ((a (ref (uq Mat)) (b (ref (uq Mat))))
    (for (i int 0) (< i (uq N)) (incv i)
      (for (j int 0) (< j (uq M)) (incv j)
        (setv (@$' (@:@ retval elements) i j)
              (+ (@$' (@:@ a elements) i j)
                 (@$' (@:@ b elements) i j)))))))))

#| ;;This won't work yet, how do I get the value-type T of Mat outsinde of function
(def-concept-macro * extern ((Mat Matrix))
  (def N (var auto \ (qq size (@ retval) 0)))
  (def M (var auto \ (qq size (@ retval) 1)))
  (def T (var auto \ (qq value-type retval)))
  (qq def * (fn extern (retval (uq Mat)) ((a (ref (uq Mat)) (b T)))
    (for (i int 0) (< i (uq N)) (incv i)
      (for (j int 0) (< j (uq M)) (incv j)
        (setv (@$' (@:@ retval elements) i j)
              (* (@$' (@:@ a elements) i j) b)))))))

;;same problem here, also for matrix size
(def-concept-macro * extern ((Mat1 Matrix) (Mat2 Matrix))
  (def N (var auto \ (qq size (@ b) 0)))
  (def M (var auto \ (qq size (@ a) 1)))
  (def P (var auto \ (qq size (@ a) 0)))
  (def P0 (var auto \ (qq size (@ b) 1)))
  (def T (var auto \ (qq value-type a)))
  (qq def * (fn (retval (Matrix (uq T) (uq N) (uq M))) ((a (ref (uq Mat1))) (b (ref (uq Mat2))))
    (assert (= (uq P) (uq P0)))
    (for (i int 0) (< i (uq M)) (incv i)
      (for (j int 0) (< j (uq N)) (incv j)
        (setv (@$' (@:@ retval elements) i j) (coerce 0 T)

          (for (k int 0) (< k (uq P)) (incv k)
          
          (incf (# (@$' (@:@ retval elements)))
                (* (@$' (@:@ a elements) i k)
                   (@$' (@:@ b elements) k j))))))))))
|#

))



