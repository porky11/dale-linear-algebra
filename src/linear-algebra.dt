(module linear-algebra)

(import util)
(import array)
(import concepts)

(using-namespace std.concepts
(using-namespace std.macros

(def-concept Matrix (refines Type) (T) true) ;;will have to define 2d dimension function and value type and 2d accessor

(def-type-macro3 Matrix)

;;TODO use a generic multidimensional Array type for representing Matrices
(def-concept-macro Matrix extern ((T Type) (N Value) (M Value))
  (let ((Mat \ (qq Matrix (uq T) (uq N) (uq M)))
        (TMat \ (qq Matrix (uq T) (uq M) (uq M))))
    (qq do
      (def (uq Mat)
        (struct extern ((elements (array-of (uq N) (array-of (uq M) (uq T)))))))
      (std.concepts.implement Matrix (uq Mat))
      (def print
        (fn intern void ((m (ref (uq Mat))))
          (in-range i 0 (- (uq M) 1)
            (in-range j 0 (- (uq N) 1)
              (printf "%3d " (@$' (@:@ m elements) i j)))
            (printf "\n"))))
      (def identity-matrix (fn extern void ((mat (ref (uq Mat))))
        (in-range i 0 (- (uq M) 1)
          (in-range j 0 (- (uq N) 1)
            (setf (# (@$' (@:@ mat elements) i j)) (if (= i j) (cast 1 (uq T)) (cast 0 (uq T))))))))
      (def frobenius-norm (fn extern (retval (uq T)) ((a (ref (uq Mat))))
        (setf retval (cast 0 (uq T)))
        (in-range i 0 (- (uq M) 1)
          (in-range j 0 (- (uq N) 1)
            (incf retval (@$' (@:@ a elements) i j))))))
      (def transpose (fn extern (retval (uq TMat)) ((a (ref (uq Mat))))
        (in-range i 0 (- (uq M) 1)
          (in-range j 0 (- (uq N) 1)
            (setf (# (@$' (@:@ retval elements) j i))
                     (@$' (@:@ a elements) i j))))))
      (def value-type (macro extern ((matp (p (uq Mat))))
        (q (uq T))))
      (def size (fn extern size ((matp (ref (const (uq Mat)))))
        (cast (* (uq M) (uq N)) size)))
      (def rank (fn extern size ((matp (ref (const (uq Mat)))))
        (cast 2 size)))
      (def dimension (fn extern size ((matp (ref (const (uq Mat)))) (a int))
        (cast (if (= a 0) (uq N) (uq M)) size))))))

(def-concept-macro + extern ((Mat Matrix))
  (def N (var auto \ (qq dimension (@ retval) 0)))
  (def M (var auto \ (qq dimension (@ retval) 1)))
  (qq def + (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (ref (uq Mat))))
    (for (i int 0) (< i (cast (uq N) int)) (incv i)
      (for (j int 0) (< j (cast (uq M) int)) (incv j)
        (setf (# (@$' (@:@ retval elements) i j))
              (+ (@$' (@:@ a elements) i j)
                 (@$' (@:@ b elements) i j))))))))

(def-concept-macro * extern ((Mat Matrix))
  (def N (var auto \ (qq dimension (@ retval) 0)))
  (def M (var auto \ (qq dimension (@ retval) 1)))
  (qq def * (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (value-type (nullptr (uq Mat)))))
    (for (i int 0) (< i (cast (uq N) int)) (incv i)
      (for (j int 0) (< j (cast (uq M) int)) (incv j)
        (setf (# (@$' (@:@ retval elements) i j))
              (* (@$' (@:@ a elements) i j) b)))))))

(def-concept-macro / extern ((Mat Matrix))
  (def N (var auto \ (qq dimension (@ retval) 0)))
  (def M (var auto \ (qq dimension (@ retval) 1)))
  (qq def * (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (value-type (nullptr (uq Mat)))))
    (for (i int 0) (< i (cast (uq N) int)) (incv i)
      (for (j int 0) (< j (cast (uq M) int)) (incv j)
        (setf (# (@$' (@:@ retval elements) i j))
              (/ (@$' (@:@ a elements) i j) b)))))))

(def-concept-macro * extern ((Mat1 Matrix) (Mat2 Matrix))
  (def N (var auto \ (qq dimension (@ b) 0)))
  (def M (var auto \ (qq dimension (@ a) 1)))
  (def P (var auto \ (qq dimension (@ a) 0)))
  (def P0 (var auto \ (qq dimension (@ b) 1)))
  (qq def * (fn extern (retval (Matrix (value-type (nullptr (uq Mat1)))
                                       (uq N) (uq M)))
                ((a (ref (uq Mat1))) (b (ref (uq Mat2))))
    (assert (= (uq P) (uq P0)))
    (for (i int 0) (< i (uq M)) (incv i)
      (for (j int 0) (< j (uq N)) (incv j)
        (setv (@$' (@:@ retval elements) i j) (coerce 0 T)

          (for (k int 0) (< k (uq P)) (incv k)
          
          (incf (# (@$' (@:@ retval elements)))
                (* (@$' (@:@ a elements) i k)
                   (@$' (@:@ b elements) k j))))))))))

))



