(module linear-algebra)

(import util)
(import array)
(import concepts)

(using-namespace std.concepts
(using-namespace std.macros

(def-concept Matrix (refines Type) (T) true) ;;will have to define 2d dimension function and value type and 2d accessor

(def-type-macro3 Matrix)

;;TODO use a generic multidimensional Array type for representing Matrices
(def-concept-macro Matrix extern ((T Type) (N Value) (M Value))
  (let ((Mat \ (qq Matrix (uq T) (uq N) (uq M)))
        (TMat \ (qq Matrix (uq T) (uq M) (uq M))))
    (qq do
      (def (uq Mat)
        (struct extern ((elements (array-of (uq N) (array-of (uq M) (uq T)))))))
      (std.concepts.implement Matrix (uq Mat))
      (def print
        (fn intern void ((m (ref (uq Mat))))
          (in-range i 0 (- (uq M) 1)
            (in-range j 0 (- (uq N) 1)
              (printf "%3d " (@$' (@:@ m elements) i j)))
            (printf "\n"))))
      (def identity-matrix (fn extern void ((mat (ref (uq Mat))))
        (in-range i 0 (- (uq M) 1)
          (in-range j 0 (- (uq N) 1)
            (setf (# (@$' (@:@ mat elements) i j)) (if (= i j) (cast 1 (uq T)) (cast 0 (uq T))))))))
      (def frobenius-norm (fn extern (retval (uq T)) ((a (ref (uq Mat))))
        (setf retval (cast 0 (uq T)))
        (in-range i 0 (- (uq M) 1)
          (in-range j 0 (- (uq N) 1)
            (incf retval (@$' (@:@ a elements) i j))))))
      (def transpose (fn extern (retval (uq TMat)) ((a (ref (uq Mat))))
        (in-range i 0 (- (uq M) 1)
          (in-range j 0 (- (uq N) 1)
            (setf (# (@$' (@:@ retval elements) j i))
                     (@$' (@:@ a elements) i j))))))
      (def value-type (macro extern ((matp (p (uq Mat))))
        (q (uq T))))
      (def size (fn extern size ((matp (ref (const (uq Mat)))))
        (cast (* (uq M) (uq N)) size)))
      (def rank (fn extern size ((matp (ref (const (uq Mat)))))
        (cast 2 size)))
      (def dimension (fn extern size ((matp (ref (const (uq Mat)))) (a int))
        (cast (if (= a 0) (uq N) (uq M)) size)))
      (def size-n (macro extern ((matp (p (Matrix (uq T) (uq N) (uq M)))))
        (q (uq N))))
      (def size-m (macro extern ((matp (p (Matrix (uq T) (uq N) (uq M)))))
        (q (uq M)))))))

(def-concept-macro + extern ((Mat Matrix))
  (def N (var auto \ (qq size-n (nullptr (uq Mat)))))
  (def M (var auto \ (qq size-m (nullptr (uq Mat)))))
  (qq def + (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (ref (uq Mat))))
    (in-range i 0 (- (uq N) 1)
      (in-range j 0 (- (uq M) 1)
        (setf (# (@$' (@:@ retval elements) i j))
              (+ (@$' (@:@ a elements) i j)
                 (@$' (@:@ b elements) i j))))))))

(def-concept-macro * extern ((Mat Matrix))
  (def N (var auto \ (qq size-n (nullptr (uq Mat)))))
  (def M (var auto \ (qq size-m (nullptr (uq Mat)))))
  (qq def * (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (value-type (nullptr (uq Mat)))))
    (in-range i 0 (- (uq N) 1)
      (in-range j 0 (- (uq M) 1)
        (setf (# (@$' (@:@ retval elements) i j))
              (* (@$' (@:@ a elements) i j) b)))))))

(def-concept-macro / extern ((Mat Matrix))
  (def N (var auto \ (qq dimension (@ retval) 0)))
  (def M (var auto \ (qq dimension (@ retval) 1)))
  (qq def * (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (value-type (nullptr (uq Mat)))))
    (in-range i 0 (- (uq N) 1)
      (in-range j 0 (- (uq M) 1)
        (setf (# (@$' (@:@ retval elements) i j))
              (/ (@$' (@:@ a elements) i j) b)))))))

(def-concept-macro * extern ((Mat1 Matrix) (Mat2 Matrix))
  (def N  (var auto \ (qq size-n (nullptr (uq Mat2)))))
  (def M  (var auto \ (qq size-m (nullptr (uq Mat1)))))
  (def P  (var auto \ (qq size-n (nullptr (uq Mat1)))))
  (def P0 (var auto \ (qq size-m (nullptr (uq Mat2)))))
  (def T  (var auto \ (qq value-type (nullptr (uq Mat1)))))

  (qq do
    (import assert)
    (def * (fn extern (retval (Matrix (uq T) (uq N) (uq M)))
                      ((a (ref (uq Mat1))) (b (ref (uq Mat2))))
      (std.assert (= (uq P) (uq P0)))
      (in-range i 0 (- (uq N) 1)
        (in-range j 0 (- (uq M) 1)
          (setf (# (@$' (@:@ retval elements) i j)) (cast 0 (uq T)))
          (in-range k 0 (- (uq P) 1)
            (incf (# (@$' (@:@ retval elements) i j))
                  (* (@$' (@:@ a elements) i k)
                     (@$' (@:@ b elements) k j))))))))))
))
