(module linear-algebra)

(import util)
(import array)
(import concepts)

(using-namespace std.concepts
(using-namespace std.macros

(def-concept Matrix (refines Type) (T) true) ;;will have to define 2d size function and value type and 2d accessor

(def-type-macro3 Matrix)

;;TODO use a generic multidimensional Array type for representing Matrices
(def-concept-macro Matrix extern ((T Type) (N Value) (M Value))
  (let ((Mat \ (qq Matrix (uq T) (uq N) (uq M))))
    (qq do
      (def (uq Mat)
        (struct extern ((elements (array-of (uq N) (array-of (uq M) (uq T)))))))
      (std.concepts.implement Matrix (uq Mat))
      (def frobenius-norm (fn extern (retval (uq T)) ((a (ref (uq Mat))))
        (setf retval (cast 0 (uq T)))
        (for (i int 0) (< i (uq M)) (incv i)
          (for (j int 0) (< j (uq N)) (incv j)
            (incf retval (@$' (@:@ a elements) i j))))))
      (def transpose (fn extern (retval (uq Mat)) ((a (ref (uq Mat))))
        (for (i int 0) (< i (uq M)) (incv i)
          (for (j int 0) (< j (uq N)) (incv j)
            (setf (# (@$' (@:@ retval elements) j i))
                  (@$' (@:@ a elements) i j))))))
      (def value-type (macro extern ((matp (p (Matrix (uq T) (uq N) (uq M)))))
        (q (uq T))))
      (def size-n (macro extern ((matp (p (Matrix (uq T) (uq N) (uq M)))))
        (q (uq N))))
      (def size-m (macro extern ((matp (p (Matrix (uq T) (uq N) (uq M)))))
        (q (uq M))))
      )))

(def-concept-macro + extern ((Mat Matrix))
  (def N (var auto \ (qq size-n (nullptr (uq Mat)))))
  (def M (var auto \ (qq size-m (nullptr (uq Mat)))))
  (qq def + (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (ref (uq Mat))))
    (for (i int 0) (< i (cast (uq N) int)) (incv i)
      (for (j int 0) (< j (cast (uq M) int)) (incv j)
        (setf (# (@$' (@:@ retval elements) i j))
              (+ (@$' (@:@ a elements) i j)
                 (@$' (@:@ b elements) i j))))))))

;;This won't work yet, how do I get the value-type T of Mat outsinde of function
(def-concept-macro * extern ((Mat Matrix))
  (def N (var auto \ (qq size-n (nullptr (uq Mat)))))
  (def M (var auto \ (qq size-m (nullptr (uq Mat)))))
  (qq def * (fn extern (retval (uq Mat)) ((a (ref (uq Mat))) (b (value-type (nullptr (uq Mat)))))
    (for (i int 0) (< i (cast (uq N) int)) (incv i)
      (for (j int 0) (< j (cast (uq M) int)) (incv j)
        (setf (# (@$' (@:@ retval elements) i j))
              (* (@$' (@:@ a elements) i j) b)))))))

;;same problem here, also for matrix size
(def-concept-macro * extern ((Mat1 Matrix) (Mat2 Matrix))
  (def N  (var auto \ (qq size-n (nullptr (uq Mat2)))))
  (def M  (var auto \ (qq size-m (nullptr (uq Mat1)))))
  (def P  (var auto \ (qq size-n (nullptr (uq Mat1)))))
  (def P0 (var auto \ (qq size-m (nullptr (uq Mat2)))))

  (qq do
    (import assert)
    (def * (fn extern (retval (Matrix (value-type (nullptr (uq Mat1)))
                                      (uq N) (uq M)))
                ((a (ref (uq Mat1))) (b (ref (uq Mat2))))
    (std.assert (= (uq P) (uq P0)))
    (for (i int 0) (< i (uq M)) (incv i)
      (for (j int 0) (< j (uq N)) (incv j)
;        (setf (# (@$' (@:@ retval elements) i j)) (coerce 0 T))
;        (for (k int 0) (< k (uq P)) (incv k)
;          (incf (# (@$' (@:@ retval elements) i j))
;                (* (@$' (@:@ a elements) i k)
;                   (@$' (@:@ b elements) k j))))

        0))))))
))
